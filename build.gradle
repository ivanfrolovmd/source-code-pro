def workDir = file("$buildDir/prep")
def fontName = "Source Code Pro With Ligatures"  // TODO font name

task prepareLigatures {
  def originalDir = file("$projectDir/ligatures")
  def toDir = file("$buildDir/ligatures")

  doLast {
    delete(toDir)
    copy {
      from originalDir
      into toDir
    }

    fileTree(dir: "$buildDir/ligatures", include: "**/*.glif").each { File theFile ->
      def WIDTH = 600

      def widths = file("$originalDir/${toDir.toPath().relativize(theFile.toPath())}").parentFile.listFiles().collectEntries {
        def gl = new XmlSlurper().parse(it)
        [gl.'@name'.text(), gl.advance.'@width'.text() as int]
      }

      def glyph = new XmlParser().parse(theFile)
      glyph.lib.each { glyph.remove(it) }

      int xFactor = (glyph.advance.'@width'[0] as int) / WIDTH
      if (xFactor > 1) {
        glyph.advance*.'@width' = 600
        glyph.outline.contour.point.each { it.'@x' = (it.'@x' as int) - WIDTH * (xFactor - 1) }
        glyph.outline.component.each {
          def deltaError = (((it.'@xScale' ?: 1) as double) < 0 ? -1 : 1) * (((widths[it.'@base'] ?: WIDTH) as int) - WIDTH)
          if (it.'@xOffset') {
            it.'@xOffset' = (it.'@xOffset' as int) - WIDTH * (xFactor - 1) + deltaError
          } else {
            it.'@xOffset' = 0 - WIDTH * (xFactor - 1) + deltaError
          }
        }
      }

      theFile.text = groovy.xml.XmlUtil.serialize(glyph)
    }
  }
}

task copyOriginals(type: Copy) {
  dependsOn 'prepareLigatures'
  from(projectDir) {
    exclude "build"
    exclude ".*"
    exclude "target"
    exclude "ligatures"
    exclude "*gradle*"
  }
  from "$buildDir/ligatures"
  into workDir

  doFirst {
    delete(workDir)
  }
}

task renameFont(type: Copy) {
  dependsOn 'copyOriginals'
  into workDir
  from(projectDir) {
    include "FontMenuNameDB"
  }
  filter { String line -> line.replace("Source Code Pro", fontName) }
}

task fillInContentPlist(dependsOn: 'copyOriginals') {
  doLast {
    fileTree(dir: workDir, include: "**/master_*/**/contents.plist").each { File plist ->
      File originalDir = file("$projectDir/ligatures/" + workDir.toPath().relativize(plist.parentFile.toPath()))
      def glyphs = originalDir.listFiles() ?: []
      def keys = glyphs.collect { File file ->
        def name = new XmlSlurper().parse(file).'@name'[0]
        "<key>$name</key>\n<string>${file.name}</string>\n"
      }.join()
      plist.text = plist.text.replace("</dict>", "$keys\n</dict>")
    }
  }
}

task fillGlyphOrderDB(dependsOn: 'copyOriginals') {
  doLast {
    def all = fileTree(dir: "$projectDir/ligatures", include: "**/*.glif").collect { new XmlSlurper().parse(it).'@name'.text() } as Set
    all = all.sort()

    def str = all.sort().withIndex().collect { el, ix -> "uni${Integer.toHexString(0xE100 + ix).toUpperCase()} $el" }.join("\n")
    fileTree(dir: workDir, include: "**/GlyphOrderAndAliasDB").each { file ->
      file.text = file.text + str + "\n"
    }

    def arrays = (0..all.size() - 1).collect { ix -> "<string>uni${Integer.toHexString(0xE100 + ix).toUpperCase()}</string>" }.join("\n")
    fileTree(dir: workDir, include: "**/master_*/**/lib.plist").each { file ->
      file.text = file.text.replace("</array>", "$arrays\n</array>")
    }
  }
}

task buildLigatureLookupTable(dependsOn: 'copyOriginals') {
  doLast {
    def all = fileTree(dir: "$projectDir/ligatures", include: "**/*.glif").collect {
      new XmlSlurper().parse(it).'@name'.text()
    } as Set
    all = all.sort { "${100 - (it.split('_').length)}$it" }

    def contents = all.collect { String name ->
      def parts = name.split("_")
      def size = parts.length

      if (size < 2) return ""

      def ignores = "ignore sub ${parts[0]} ${parts[0]}' ${(2..size).collect { parts[it - 1] }.join(" ")};\n" +
          "ignore sub ${parts[0]}' ${(2..size).collect { parts[it - 1] }.join(" ")} ${parts[size - 1]};\n"

      def lookups = (size..1).collect { subIx ->
        "sub ${"LIG " * (subIx - 1)}${parts[subIx - 1]}' ${(subIx..<size).collect { parts[it] }.join(" ")} by ${subIx == size ? name : "LIG"};\n"
      }.join()

      "lookup $name {\n$ignores$lookups} $name;\n"
    }.join("\n")

    file("$workDir/ligatures.fea").text = """
feature calt {
$contents
} calt;
"""
    file("$workDir/features.fea") << "include (../../../../ligatures.fea);\n"
  }
}

task prepare {
  dependsOn 'copyOriginals', 'renameFont', 'fillInContentPlist', 'fillGlyphOrderDB', 'buildLigatureLookupTable'
}

task buildInstances {
  dependsOn 'prepare'
  doLast {
    fileTree(dir: workDir, include: "**/Masters/**/*.designspace").each { File file ->
      exec {
        commandLine "makeInstancesUFO", "-d", file.absolutePath
      }
    }
  }
}

task buildFonts {
  dependsOn 'buildInstances'
  doLast {
    exec {
      commandLine "$workDir/build.sh"
      workingDir workDir
    }
  }
}

task prepareForEditing(type: Copy) {
  doFirst {
    delete("$buildDir/edit")
  }
  from(projectDir) {
    include "Roman/Masters/**/*.ufo/**"
    include "Italic/Masters/**/*.ufo/**"
  }
  from "$projectDir/ligatures"
  into "$buildDir/edit"

  doLast {
    println "Edit fonts in $buildDir/edit"
  }
}

task finishEditing(type: Copy) {
  def editDir = file("$buildDir/edit")

  from(editDir) {
    exclude {
      def projectFile = file("$projectDir/${editDir.toPath().relativize(it.file.toPath())}")
      projectFile.isFile() && projectFile.exists()
    }
  }
  into "$projectDir/ligatures"
}
